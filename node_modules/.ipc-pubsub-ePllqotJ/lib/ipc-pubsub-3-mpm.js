"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _cluster = _interopRequireDefault(require("cluster"));

var _patternEmitter = _interopRequireDefault(require("pattern-emitter"));

var _ipcPubsub1Util = require("./ipc-pubsub-1-util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
**  IPC-PubSub -- Inter-Process-Communication Publish-Subscribe
**  Copyright (c) 2017-2019 Dr. Ralf S. Engelschall <rse@engelschall.com>
**
**  Permission is hereby granted, free of charge, to any person obtaining
**  a copy of this software and associated documentation files (the
**  "Software"), to deal in the Software without restriction, including
**  without limitation the rights to use, copy, modify, merge, publish,
**  distribute, sublicense, and/or sell copies of the Software, and to
**  permit persons to whom the Software is furnished to do so, subject to
**  the following conditions:
**
**  The above copyright notice and this permission notice shall be included
**  in all copies or substantial portions of the Software.
**
**  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
const clusterWorkers = () => {
  const workers = [];

  for (const id in _cluster.default.workers) workers.push(_cluster.default.workers[id]);

  return workers;
};
/*  Publish-Subscribe for Multi-Process-Model (MPM)  */


class PubSub {
  constructor(url) {
    this.url = url;
    this.id = this.url.pathname;
    this.opened = false;
  }
  /*  open connection  */


  open() {
    if (this.opened) throw new Error("already opened");
    this.emitter = new _patternEmitter.default();

    this.messageHandler = message => {
      if (!(typeof message === "object" && typeof message.type === "string")) return;
      if (message.type === `PubSub:mpm:${this.id}:master`) this._publishOnMaster(message.channel, message.value);else if (message.type === `PubSub:mpm:${this.id}:worker`) this._publishOnWorker(message.channel, message.value);
    };

    if (_cluster.default.isMaster) {
      clusterWorkers().forEach(worker => {
        worker.on("message", this.messageHandler);
      });
    } else process.on("message", this.messageHandler);

    this.opened = true;
    return _promise.default.resolve();
  }
  /*  publish message to channel  */


  publish(channel, value) {
    if (!this.opened) throw new Error("still not opened");
    if (_cluster.default.isMaster) return this._publishOnMaster(channel, value);else {
      return new _promise.default((resolve, reject) => {
        process.send({
          type: `PubSub:mpm:${this.id}:master`,
          channel: channel,
          value: value
        }, err => {
          if (err) reject(err);else resolve();
        });
      });
    }
  }

  _publishOnMaster(channel, value) {
    this.emitter.emit(channel, value);
    return _promise.default.all(clusterWorkers().map(worker => {
      return new _promise.default((resolve, reject) => {
        worker.send({
          type: `PubSub:mpm:${this.id}:worker`,
          channel: channel,
          value: value
        }, err => {
          if (err) reject(err);else resolve();
        });
      });
    }));
  }

  _publishOnWorker(channel, value) {
    this.emitter.emit(channel, value);
    return _promise.default.resolve();
  }
  /*  subscribe to channel(s) for messages  */


  subscribe(channelPrefix, callback) {
    if (!this.opened) throw new Error("still not opened");
    const channelRegexp = new RegExp(`^${(0, _ipcPubsub1Util.pattern2regexp)(channelPrefix)}$`);

    const handler = function (message) {
      callback(message, this.event);
    };

    this.emitter.on(channelRegexp, handler);
    return _promise.default.resolve({
      unsubscribe: () => {
        this.emitter.removeListener(channelRegexp, handler);
        return _promise.default.resolve();
      }
    });
  }
  /*  close connection  */


  close() {
    if (!this.opened) throw new Error("still not opened");
    process.removeListener("message", this.messageHandler);
    delete this.messageHandler;
    delete this.emitter;
    this.opened = false;
    return _promise.default.resolve();
  }

}

exports.default = PubSub;
